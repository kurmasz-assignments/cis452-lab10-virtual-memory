CIS 452 Lab 10:  Virtual Memory Concepts
------------------------------------------------------------------------

### Overview

The purpose of this lab assignment is to conduct and interpret experiments that
introduce virtual memory concepts.
Specifically, the lab investigates the effect of memory-intensive process
execution, frame allocation policies, and page replacement by observing
periodic system reports of virtual memory statistics.

### Virtual Memory Performance Statistics

Self-monitoring is a task performed by most operating systems -
it is useful for administration and auditing purposes.
Since there are many subsystems in a typical OS,
there are many different performance auditing utilities.
This lab concerns virtual memory, hence,
the primary tool used will be `vmstat` (virtual memory statistics).
The utility programs `free` and `top` also give memory usage statistics. 
Begin by reading the man pages for these utilities to get an idea of the types
of information they provide and the various output options available via
command-line parameters.

The `vmstat` utility is typically used by system administrators to
characterize the performance of a system.
For example, to an administrator,
a large number of swapped processes and a large amount of active virtual memory
is indicative of a system with a severe memory shortage
(and high paging activity) => time to install more RAM.

**Note**:  there are several different types of memory, and memory measures,
referred to in this lab.
Be sure you understand the difference and the correct use of each metric.
Also, pay special attention to the units;
i.e., does a utility report memory usage in bytes, kilobytes (KB), megabytes
(MB), etc.

Study the following test program;
in particular, note its memory demand requirements (the `malloc()` request)
and its memory access profile (the loop).
The value `dim` (dimension) is expressed as `COEFFICIENT` Kilobytes and is used
to control memory demand by creating a two-dimensional `dim × dim` matrix of
integers.
The value `LOOP` is used solely to keep the program executing long enough to
observe its memory demand with the `vmstat` utility.

*Sample Program*

```c
#include <stdio.h>
#include <stdlib.h>

#define COEFFICIENT 8
#define LOOP 200000

int main()
{
   int count, *intPtr;

   long int i, j, dim = COEFFICIENT * 1024;

   size_t desired_size = dim * dim * sizeof(int);
   printf("About to malloc %ld\n", desired_size);
   if ((intPtr = malloc (desired_size)) == 0) {
      perror ("totally out of space");
      exit (1);
   }
   for (count=1; count<=LOOP; count++)
      for (i=0; i<dim; i++)
         for (j=0; j<dim; j++)
            intPtr[i * dim + j] = (i + j) % count;

   free (intPtr);
   return 0;
}
```

### Determine your system configuration:

**Important** This lab will probably not work as expected on a virtual machine.

1. specify what system you are working on
2. use the `free` memory utility program to determine and report: 
    * the total amount of *physical* memory (MB) on your system 
    * the current amount of *free* memory (MB)
    * the total amount of *swap* space

### Examine and observe the memory demand of an executing process:

  * Study the sample program

    3. What is your estimate of the approximate memory demand of the sample program?
  
  * Start `vmstat`, make your window appropriately wide,
    and configure it to display statistics once per second;
    let the system stabilize
  
      * Note: these experiments are best performed on a "quiet" system
        (i.e. not many active users)
  
  * In another window, execute the sample program.

      4. Approximately how much does the amount of free (idle) memory change?
      5. Considering your estimated memory demand of the sample program
        (question 3), explain why the observed change is an expected result.
  
  * Reduce the value of `LOOP` in the sample program to 25. 
    * If you don't want to modify the source code, you can add `-DLOOP=25` to your compile command.

  * Read the man pages for the `time` utility program.
    Then use `/usr/bin/time` together with command-line arguments as described for
    `time` to obtain complete statistics (i.e. run in `verbose` mode).

  * Execute and time the sample program. (Note, you will have to use `/usr/bin/time`, not just `time`.)
  
  * Obtain basic statistics
     
    6. How long does the program take to run?
    7. What is the size of a page in Linux?
    8. How many pages of memory do you expect this program to touch?

  9. Explain the difference between a "Major" page fault and a "Minor" page fault. (It's OK to ask Google, ChatGPT, or the professor for some help here.)

  10. How many of each page fault are generated by the sample program.

  11. Explain why this observation makes sense.

  12. Set `LOOP` to 1 and determine the value of `COEFFICENT` that causes major page faults.

  13. How many major page faults were there for this value of `COEFFICIENT`? 

  14. Set `LOOP` to 2 and report the number of major page faults.

  15. Why does the second iteration of the loop produce so many page faults? 

  16. What does this tell you about the page replacement policy?


### Examine the effects of using too much memory.

  17. Determine how large `COEFFICIENT` can get before the process is unable to complete.

  18. What happens when `COEFFICIENT` is too large? (What do you observe when trying to run the program?)

  * Set `COEFFICIENT` back near to the largest value that will allow the program to complete.

  * Open another window, and run the program simultaneously in each window.

  19. Describe what happens, and explain why.
  
    
### Examine the effect of memory access patterns:

  * Consider what happens if teh memory access statement is changed to the following:
    ```c
    intPtr[j * dim + i] = (i + j) % count;
    ```

  20. Does this change affect the contents of the array? If so, explain how. If not, explain why not. 

  21. Describe *precisely* how does this change alters the program's memory access
      *pattern*.  What memory addresses, pages, and frames get "touched", and in what order?
      A diagram will help here.

  22. Complete the table below:

<!-- only needed for preview on VS Code
<style>
table { border-collapse: collapse; }
td { border: 1px solid #ccc; padding: 4px;  }
th { outline: 0.5px solid #ddd; padding: 5px; text-align: center; font-weight: normal; }
thead tr:first-child th { border-bottom: none; }
thead tr:nth-child(2) th { border-top: none; }
</style>
--> 

<table>
<thead>
  <tr>
    <th></th>
    <th colspan="2" >Coefficient 2; Loop 100</th>
    <th colspan="2" >Coefficient 8; Loop 10</th>
    <th colspan="2" >Coefficient 64; Loop 2</th>
    <th colspan="2" >Coefficient 64; Loop 1</th>
  </tr>
  <tr>
    <th></th>
    <th>Row Major</th><th>Column Major</th>
    <th>Row Major</th><th>Column Major</th>
    <th>Row Major</th><th>Column Major</th>
    <th>Row Major</th><th>Column Major</th>
  </tr>
  </thead>
  <tbody>
  <tr><td>Time:</td><td>&nbsp;</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
  <tr><td>Major Faults:</td><td>&nbsp;</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
  <tr><td>Minor Faults:</td><td>&nbsp;</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
  </tbody>
</table>


  23. Explain the results in the table.  Be as specific as possible. (Some of the results will have a little "noise". You don't have to account for all the noise.)

